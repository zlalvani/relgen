import type { AnthropicMessagesModelId } from '@ai-sdk/anthropic/internal';
import type { OpenAIChatModelId } from '@ai-sdk/openai/internal';
import { LinearClient } from '@linear/sdk';
import dedent from 'dedent';
import type { File } from 'gitdiff-parser';
import pino from 'pino';
import { group, parallel, unique } from 'radashi';
import type { MergeExclusive } from 'type-fest';
import { type GithubClient, createGithubClient } from './clients/github';
import { makeContext } from './contexts';
import {
  type LanguageModelService,
  type PullRequestDescribe,
  PullRequestDescribeSchema,
  createLanguageModelService,
} from './services/llm';

export type RelgenOptions = {
  llm:
    | {
        apiKey: string;
        provider: 'openai';
        model: OpenAIChatModelId;
      }
    | {
        apiKey: string;
        provider: 'anthropic';
        model: AnthropicMessagesModelId;
      };
  write?: {
    release?: boolean;
    pr?: boolean;
    issue?: boolean;
  };
  logger?: pino.Logger;
  integrations: {
    github: {
      token: string;
    };
  } & MergeExclusive<
    {
      linear?: {
        token: string;
      };
    },
    {
      jira?: {
        token: string;
      };
    }
  >;
};

const excludedFiles = new Set([
  'package-lock.json',
  'yarn.lock',
  'pnpm-lock.yaml',
]);

const RELGEN_TAG = '<!-- Generated by Relgen -->';

function serializePullRequestRelgenMetadata(metadata: PullRequestDescribe) {
  return dedent`
  <!-- METADATA
  ${JSON.stringify(metadata)}
  -->
  `;
}

function getPullRequestRelgenMetadata(body?: string) {
  if (!body) {
    return null;
  }

  const parsed = PullRequestDescribeSchema.safeParse(
    JSON.parse(
      body.match(/<!-- METADATA\n(.*?)\n-->/s)?.[1]?.replaceAll('\n', '\\n') ??
        '{}'
    )
  );

  if (!parsed.success) {
    return null;
  }

  return parsed.data;
}

// ChatGPT generated - serialize a list of files to a GitHub diff
function serializeToGitHubDiff(files: File[]): string {
  return files
    .map((file) => {
      const oldPath = file.oldPath;
      const newPath = file.newPath;
      const oldMode = file.oldMode;
      const newMode = file.newMode;
      const oldRevision = file.oldRevision;
      const newRevision = file.newRevision;

      const lines: string[] = [];
      lines.push(`diff --git a/${oldPath} b/${newPath}`);

      // If file is renamed or copied, show similarity index, rename/copy from/to lines
      if (file.type === 'rename' || file.type === 'copy') {
        const similarity = file.similarity || 100;
        lines.push(`similarity index ${similarity}%`);
        if (file.type === 'rename') {
          lines.push(`rename from ${oldPath}`);
          lines.push(`rename to ${newPath}`);
        } else if (file.type === 'copy') {
          lines.push(`copy from ${oldPath}`);
          lines.push(`copy to ${newPath}`);
        }
      }

      // If mode changed
      if (oldMode && newMode && oldMode !== newMode) {
        lines.push(`old mode ${oldMode}`);
        lines.push(`new mode ${newMode}`);
      }

      // Show index line
      // Example: index 2c33c4f..f50b8db 100644
      lines.push(
        `index ${oldRevision.substring(0, 7)}..${newRevision.substring(0, 7)} ${newMode}`
      );

      // Show old/new path lines, omit if file is added or deleted
      if (file.type !== 'add' && file.type !== 'copy') {
        lines.push(`--- a/${oldPath}`);
      } else {
        // Representing no old file with `/dev/null`
        lines.push('--- /dev/null');
      }

      if (file.type !== 'delete' && file.type !== 'copy') {
        lines.push(`+++ b/${newPath}`);
      } else {
        // Representing no new file with `/dev/null`
        lines.push('+++ /dev/null');
      }

      // Hunks
      for (const hunk of file.hunks) {
        const hunkHeader = `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`;
        lines.push(hunkHeader + (hunk.content ? ` ${hunk.content}` : ''));

        for (const change of hunk.changes) {
          if (change.type === 'normal') {
            lines.push(` ${change.content}`);
          } else if (change.type === 'insert') {
            lines.push(`+${change.content}`);
          } else if (change.type === 'delete') {
            lines.push(`-${change.content}`);
          }
        }
      }

      return lines.join('\n');
    })
    .join('\n');
}

const relgen = ({
  args,
  deps,
}: {
  args: {
    write: {
      release: boolean;
      pr: boolean;
      issue: boolean;
    };
  };
  deps: {
    llm: LanguageModelService;
    github: GithubClient;
    logger: pino.Logger;
    linear?: LinearClient;
  };
}) => {
  const { llm, github, logger } = deps;

  const getUnreleasedPrs = async ({
    owner,
    repo,
  }: {
    owner: string;
    repo: string;
  }) => {
    const githubRepo = await github.$rest.repos.get({
      owner,
      repo,
    });

    const defaultBranch = githubRepo.data.default_branch;

    const latest = await github.rest.repos.getLatestRelease({
      owner,
      repo,
    });

    return (
      await github.rest.search.issuesAndPullRequests({
        repo: {
          owner,
          repo,
        },
        type: 'pr',
        base: defaultBranch,
        status: 'merged',
        mergedAfter: latest?.data.published_at
          ? new Date(latest.data.published_at)
          : undefined,
      })
    ).data.items;
  };

  const getPrsBetweenTags = async ({
    owner,
    repo,
    fromTag,
    toTag,
  }: {
    owner: string;
    repo: string;
    fromTag?: string;
    toTag?: string;
  }) => {
    const githubRepo = await github.$rest.repos.get({
      owner,
      repo,
    });

    const defaultBranch = githubRepo.data.default_branch;

    const from = fromTag
      ? await github.$rest.repos.getReleaseByTag({
          owner,
          repo,
          tag: fromTag,
        })
      : undefined;

    const to = toTag
      ? await github.$rest.repos.getReleaseByTag({
          owner,
          repo,
          tag: toTag,
        })
      : undefined;

    return (
      await github.rest.search.issuesAndPullRequests({
        repo: {
          owner,
          repo,
        },
        type: 'pr',
        base: defaultBranch,
        status: 'merged',
        mergedAfter: from?.data.published_at
          ? new Date(from.data.published_at)
          : undefined,
        mergedBefore: to?.data.published_at
          ? new Date(to.data.published_at)
          : undefined,
      })
    ).data.items;
  };

  const getTimerangePrs = async ({
    owner,
    repo,
    from,
    to,
  }: {
    owner: string;
    repo: string;
    from?: Date;
    to?: Date;
  }) => {
    const githubRepo = await github.$rest.repos.get({
      owner,
      repo,
    });

    const defaultBranch = githubRepo.data.default_branch;

    return (
      await github.rest.search.issuesAndPullRequests({
        repo: {
          owner,
          repo,
        },
        type: 'pr',
        base: defaultBranch,
        status: 'merged',
        mergedAfter: from,
        mergedBefore: to,
      })
    ).data.items;
  };

  const ascribePrs = async ({
    owner,
    repo,
    prs,
  }: {
    owner: string;
    repo: string;
    prs: Awaited<
      ReturnType<
        | typeof getUnreleasedPrs
        | typeof getPrsBetweenTags
        | typeof getTimerangePrs
      >
    >;
  }) => {
    const comments = await github.graphql.repo.pull.batchPullRequestComments({
      owner,
      repo,
      nums: prs.map((pr) => pr.number),
    });

    const commentsLookup = comments.reduce((acc, curr) => {
      acc.set(curr.num, curr.comments);
      return acc;
    }, new Map<number, (typeof comments)[number]['comments']>());

    const metadata = await parallel(
      3,
      prs.filter((pr) => commentsLookup.has(pr.number)),
      async (pr) => {
        // biome-ignore lint/style/noNonNullAssertion: <already filtered>
        const prComments = commentsLookup.get(pr.number)!;

        // TODO: also filter for author
        const relgenComment = pr.body?.includes(RELGEN_TAG)
          ? pr.body
          : prComments.find((comment) => comment.body?.includes(RELGEN_TAG))
              ?.body;

        return {
          pr,
          metadata:
            getPullRequestRelgenMetadata(relgenComment) ??
            (await (async () => {
              const diff = await github.rest.pulls.diff({
                owner,
                repo,
                num: pr.number,
              });
              const result = await llm.pr.describe({
                change: {
                  pr: makeContext({
                    source: 'github',
                    type: 'pr',
                    data: pr,
                    prompt: dedent`
                      <pr>
                        <title>${pr.title}</title>
                        <body>${pr.body}</body>
                      </pr>
                      `,
                  }),
                  diff: makeContext({
                    source: 'github',
                    type: 'diff',
                    data: diff,
                    prompt: dedent`
                      <diff>
                        <raw>
                        ${serializeToGitHubDiff(
                          diff.data.files
                            .filter((file) => !file.isBinary)
                            .map((file) => {
                              return {
                                ...file,
                                oldName: file.oldPath.split('/').pop(),
                                newName: file.newPath.split('/').pop(),
                              };
                            })
                            .filter(
                              (file) =>
                                file.oldName &&
                                file.newName &&
                                !excludedFiles.has(file.oldName) &&
                                !excludedFiles.has(file.newName)
                            )
                        )}
                        </raw>
                      </diff>
                      `,
                  }),
                },
              });

              return result.object;
            })()),
        };
      }
    );

    return Object.entries(
      group(metadata, (item) => item.pr.user?.login ?? 'unknown')
    )
      .filter(<K, V>(entry: [K, V | undefined]): entry is [K, V] => !!entry[1])
      .map(([author, items]) => {
        return {
          author,
          items: items.map((item) => {
            return {
              pr: {
                title: item.pr.title,
                url: item.pr.html_url,
              },
              relgen: item.metadata,
            };
          }),
        };
      });
  };

  return {
    remote: {
      ascribe: async (
        args: {
          owner: string;
          repo: string;
          from?: Date;
          to?: Date;
        },
        options?: {
          excludedPattern?: RegExp;
        }
      ) => {
        const { owner, repo, from, to } = args;
        const prs = (await getTimerangePrs({ owner, repo, from, to })).filter(
          (pr) =>
            !options?.excludedPattern ||
            !options?.excludedPattern.test(pr.title)
        );

        return ascribePrs({
          owner,
          repo,
          prs,
        });
      },
      release: {
        ascribe: async (
          args: {
            owner: string;
            repo: string;
          } & MergeExclusive<
            {
              toTag?: string;
              fromTag?: string;
            },
            {
              unreleased?: true;
            }
          >,
          options?: {
            excludedPattern?: RegExp;
          }
        ) => {
          const { owner, repo, toTag, fromTag, unreleased } = args;

          const selectedPrs = (
            unreleased
              ? await getUnreleasedPrs({ owner, repo })
              : await getPrsBetweenTags({
                  owner,
                  repo,
                  fromTag,
                  toTag,
                })
          ).filter(
            (pr) =>
              !options?.excludedPattern ||
              !options?.excludedPattern.test(pr.title)
          );

          if (!selectedPrs.length) {
            return null;
          }

          return ascribePrs({
            owner,
            repo,
            prs: selectedPrs,
          });
        },
        describe: async (
          args: {
            owner: string;
            repo: string;
          } & MergeExclusive<
            {
              toTag?: string;
              fromTag?: string;
            },
            {
              unreleased?: true;
            }
          >,
          options?: {
            persona?: 'marketing' | 'engineering' | 'product' | 'leadership';
            write?:
              | {
                  name: string;
                  tag: string;
                }
              | false;
            template?: string;
            prompt?: string;
            include?:
              | 'all'
              | {
                  issues?: boolean;
                  tickets?: boolean;
                  labels?: boolean;
                };
          }
        ) => {
          const { owner, repo, toTag, fromTag, unreleased } = args;

          const newPrs = unreleased
            ? await getUnreleasedPrs({ owner, repo })
            : await getPrsBetweenTags({
                owner,
                repo,
                fromTag,
                toTag,
              });

          if (!newPrs.length) {
            return null;
          }

          const issues =
            options?.include === 'all' || options?.include?.issues
              ? await github.graphql.repo.pull.batchClosingIssuesReferences({
                  owner,
                  repo,
                  nums: newPrs.map((pr) => pr.number),
                })
              : [];

          const issueMap = issues.reduce((acc, curr) => {
            acc.set(curr.num, curr.issues);
            return acc;
          }, new Map<number, (typeof issues)[number]['issues']>());

          const changeContexts = newPrs.map((pr) => {
            // Only take the first linked issue for now
            const issue = issueMap.get(pr.number)?.[0];

            // TODO: include labels for the issues and comments for both
            return {
              pr: makeContext({
                source: 'github',
                type: 'pr',
                data: pr,
                prompt: dedent`
                <pr>
                  <title>${pr.title}</title>
                  <body>${pr.body}</body>
                  ${pr.labels.length > 0 ? `<labels>${pr.labels.join(',')}</labels>` : ''}
                </pr>
                `,
              }),
              issue: issue
                ? makeContext({
                    source: 'github',
                    type: 'issue',
                    data: issue,
                    prompt: dedent`
                    <issue>
                      <title>${issue.title}</title>
                      <body>${issue.body}</body>
                    </issue>
                    `,
                  })
                : undefined,
            };
          });

          const result = await llm.release.describe(
            {
              changes: changeContexts,
            },
            {
              persona: options?.persona,
              template: options?.template,
              prompt: options?.prompt,
            }
          );

          return result.object;
        },
      },
      pr: {
        describe: async (
          args: {
            owner: string;
            repo: string;
            num: number;
          },
          options?: {
            write?: ('title' | 'comment' | 'description')[] | false;
            template?: string;
            prompt?: string;
            footer?: string;
          }
        ) => {
          const { owner, repo, num } = args;

          const { footer, prompt, template } = options ?? {};

          const selectedWrites = Array.isArray(options?.write)
            ? new Set(options.write)
            : undefined;

          const [pr, diff] = await Promise.all([
            github.$rest.pulls.get({
              owner,
              repo,
              pull_number: num,
            }),
            github.rest.pulls.diff({
              owner,
              repo,
              num,
            }),
          ]);

          const prContext = makeContext({
            source: 'github',
            type: 'pr',
            data: pr,
            prompt: dedent`
            <pr>
              <title>${pr.data.title}</title>
              <body>${pr.data.body}</body>  
            </pr>`,
          });

          const diffContext = makeContext({
            source: 'github',
            type: 'diff',
            data: diff,
            prompt: dedent`
            <diff>
              <raw>
              ${serializeToGitHubDiff(
                diff.data.files
                  .filter((file) => !file.isBinary)
                  .map((file) => {
                    return {
                      ...file,
                      oldName: file.oldPath.split('/').pop(),
                      newName: file.newPath.split('/').pop(),
                    };
                  })
                  .filter(
                    (file) =>
                      file.oldName &&
                      file.newName &&
                      !excludedFiles.has(file.oldName) &&
                      !excludedFiles.has(file.newName)
                  )
              )}
              </raw>
            </diff>,
            `,
          });

          const result = await llm.pr.describe(
            {
              change: {
                pr: prContext,
                diff: diffContext,
              },
            },
            {
              template,
              prompt,
            }
          );

          const metadata = serializePullRequestRelgenMetadata(result.object);

          const additionalContent = [footer, metadata, RELGEN_TAG]
            .filter((content) => content)
            .join('\n\n');

          const body = result.object.description
            ? `${result.object.description}\n\n${additionalContent}`
            : undefined;

          if (
            selectedWrites?.has('description') ||
            selectedWrites?.has('title')
          ) {
            await github.$rest.pulls.update({
              owner,
              repo,
              pull_number: num,
              title: selectedWrites?.has('title')
                ? result.object.title
                : undefined,
              body: selectedWrites?.has('description') ? body : undefined,
            });
          }

          if (selectedWrites?.has('comment') && body) {
            const comments = await github.$rest.issues.listComments({
              owner,
              repo,
              issue_number: num,
            });

            const username = (await github.rest.users.getAuthenticated())?.data
              .login;

            logger.debug({
              username,
            });

            const existingComment = comments.data.find(
              (comment) =>
                comment.body?.includes(RELGEN_TAG) &&
                (!username || comment.user?.login === username)
            );

            if (existingComment) {
              await github.$rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingComment.id,
                body,
              });
            } else {
              await github.$rest.issues.createComment({
                owner,
                repo,
                issue_number: num,
                body,
              });
            }
          }

          return result.object;
        },
        label: async (
          args: {
            owner: string;
            repo: string;
            num: number;
          },
          options?: {
            write?: 'add' | 'set' | false;
            exclude?: 'existing' | string[];
            prompt?: string;
          }
        ) => {
          const { owner, repo, num } = args;

          const [labels, pr, diff] = await Promise.all([
            github.$rest.issues.listLabelsForRepo({
              owner,
              repo,
            }),
            github.$rest.pulls.get({
              owner,
              repo,
              pull_number: num,
            }),
            github.rest.pulls.diff({
              owner,
              repo,
              num,
            }),
          ]);

          const prContext = makeContext({
            source: 'github',
            type: 'pr',
            data: pr,
            prompt: dedent`
            <pr>
              <title>${pr.data.title}</title>
              <body>${pr.data.body}</body>
            </pr>
            `,
          });

          const exclude = new Set(
            Array.isArray(options?.exclude) ? options.exclude : []
          );

          const labelContexts = labels.data
            .filter((label) => !exclude.has(label.name))
            .map((label) => {
              return makeContext({
                source: 'github',
                type: 'label',
                data: label,
                prompt: dedent`
                <label>
                  <name>${label.name}</name>
                  <description>${label.description}</description>
                </label>
              `,
              });
            });

          const existingLabels = pr.data.labels.map((label) => {
            return makeContext({
              source: 'github',
              type: 'label',
              data: label,
              prompt: dedent`
              <label>
              ${
                typeof label === 'string'
                  ? `<name>${label}</name>`
                  : dedent`
                <name>${label.name}</name>`
              }
              </label>
            `,
            });
          });

          const diffContext = makeContext({
            source: 'github',
            type: 'diff',
            data: diff,
            prompt: dedent`
            <diff>
              <raw>
              ${serializeToGitHubDiff(
                diff.data.files
                  .filter((file) => !file.isBinary)
                  .map((file) => {
                    return {
                      ...file,
                      oldName: file.oldPath.split('/').pop(),
                      newName: file.newPath.split('/').pop(),
                    };
                  })
                  .filter(
                    (file) =>
                      file.oldName &&
                      file.newName &&
                      !excludedFiles.has(file.oldName) &&
                      !excludedFiles.has(file.newName)
                  )
              )}
              </raw>
            </diff>
            `,
          });

          const result = await llm.pr.label(
            {
              change: {
                pr: prContext,
                diff: diffContext,
              },
              labels: labelContexts,
              existing:
                options?.exclude === 'existing' ? undefined : existingLabels,
            },
            {
              prompt: options?.prompt,
            }
          );

          if (options?.write) {
            await github.$rest.issues.update({
              owner,
              repo,
              issue_number: num,
              labels:
                options.write === 'set'
                  ? result.object.labels
                  : unique([...pr.data.labels, ...result.object.labels]),
            });
          }

          return result.object;
        },
      },
      issue: {
        label: async (
          args: {
            owner: string;
            repo: string;
            num: number;
          },
          options?: {
            write?: 'add' | 'set' | false;
            exclude?: 'existing' | string[];
            prompt?: string;
          }
        ) => {
          const { owner, repo, num } = args;

          const [labels, issue] = await Promise.all([
            github.$rest.issues.listLabelsForRepo({
              owner,
              repo,
            }),
            github.$rest.issues.get({
              owner,
              repo,
              issue_number: num,
            }),
          ]);

          const issueContext = makeContext({
            source: 'github',
            type: 'issue',
            data: issue,
            prompt: dedent`
            <issue>
              <title>${issue.data.title}</title>
              <body>${issue.data.body}</body>
            </issue>
            `,
          });

          const exclude = new Set(
            Array.isArray(options?.exclude) ? options.exclude : []
          );

          const labelContexts = labels.data
            .filter((label) => !exclude.has(label.name))
            .map((label) => {
              return makeContext({
                source: 'github',
                type: 'label',
                data: label,
                prompt: dedent`
                <label>
                  <name>${label.name}</name>
                  <description>${label.description}</description>
                </label>
              `,
              });
            });

          const existingLabels = issue.data.labels.map((label) => {
            return makeContext({
              source: 'github',
              type: 'label',
              data: label,
              prompt: dedent`
              <label>
              ${
                typeof label === 'string'
                  ? `<name>${label}</name>`
                  : `<name>${label.name}</name>`
              }
              </label>
            `,
            });
          });

          const result = await llm.issue.label(
            {
              issue: issueContext,
              labels: labelContexts,
              existing:
                options?.exclude === 'existing' ? undefined : existingLabels,
            },
            {
              prompt: options?.prompt,
            }
          );

          if (options?.write) {
            await github.$rest.issues.update({
              owner,
              repo,
              issue_number: num,
              labels:
                options.write === 'set'
                  ? result.object.labels
                  : unique([...issue.data.labels, ...result.object.labels]),
            });
          }

          return result.object;
        },
        duplicates: async () => {
          throw new Error('Not implemented');
        },
      },
    },
    commit: {
      describe: async () => {
        throw new Error('Not implemented');
      },
    },
  };
};

export const createRelgen = (options: RelgenOptions) => {
  const { llm, integrations } = options;

  let logger = options.logger;

  logger = logger ?? pino();

  return relgen({
    args: {
      write: {
        release: options.write?.release ?? false,
        pr: options.write?.pr ?? false,
        issue: options.write?.issue ?? false,
      },
    },
    deps: {
      logger: logger,
      github: createGithubClient({ token: integrations.github.token }),
      llm: createLanguageModelService(llm, logger),
      linear:
        integrations.linear &&
        new LinearClient({ apiKey: integrations.linear.token }),
    },
  });
};

export type Relgen = ReturnType<typeof createRelgen>;
